import CarrinhoModel from '../models/carrinhoModel.js';
import PedidoModel from '../models/pedidoModel.js';
import { criarPagamentoPix, criarPagamentoCartao } from '../services/mercadoPagoService.js';
import UsuarioModel from '../models/usuarioModel.js';
import { decrypt } from '../services/cryptoService.js'; 

// --- Funções de Cliente (Existentes) ---

export const criarPedido = async (req, res, next) => {
    try {
        const id_usuario = req.user.id_usuario;
        const { id_endereco_entrega, preco_frete = 0, paymentMethod, paymentData } = req.body;

        if (!id_endereco_entrega) {
            return res.status(400).json({ message: "O endereço de entrega é obrigatório." });
        }

        const carrinhoItens = await CarrinhoModel.findByUserId(id_usuario);
        if (carrinhoItens.length === 0) {
            return res.status(400).json({ message: "Seu carrinho está vazio." });
        }

        const usuario = await UsuarioModel.findById(id_usuario);
        const cpfLimpo = decrypt(usuario[process.env.TABLE_USUARIOS_COL_CPF]);
        if (!cpfLimpo) {
            return res.status(400).json({ message: "CPF do usuário não encontrado ou inválido." });
        }

        const preco_itens = carrinhoItens.reduce((total, item) => {
            const preco = parseFloat(item.produtos.preco);
            const quantidade = parseInt(item.quantidade, 10);
            
            if (!isNaN(preco) && !isNaN(quantidade)) {
                return total + (preco * quantidade);
            }
            return total;
        }, 0);

        const preco_total = preco_itens + Number(preco_frete);

        if (preco_total <= 0) {
            return res.status(400).json({ message: "O valor total do pedido deve ser maior que zero." });
        }

        let pagamentoResult;
        let metodoPagamentoFinal = paymentMethod;

        if (paymentMethod === 'CreditCard') {
            const { token, installments, payment_method_id, issuer_id, payer } = paymentData;
            metodoPagamentoFinal = payment_method_id;
            pagamentoResult = await criarPagamentoCartao({
                amount: preco_total, token, installments, payment_method_id, issuer_id,
                payer: {
                    email: payer.email,
                    identification: { type: payer.identification.type, number: payer.identification.number }
                }
            });
        } else { // PIX
            metodoPagamentoFinal = 'pix';
            const [primeiroNome, ...sobrenomeArray] = usuario.nome_completo.split(' ');
            const sobrenome = sobrenomeArray.join(' ');
            pagamentoResult = await criarPagamentoPix({
                amount: preco_total,
                payer: { 
                    email: usuario.email, 
                    firstName: primeiroNome,
                    lastName: sobrenome,
                    identification: { type: "CPF", number: cpfLimpo }
                },
            });
        }
        
        const statusPagamento = pagamentoResult.status === 'approved' ? 'PAGO' : 'PENDENTE';

        const pedidoCriado = await PedidoModel.create({
            id_usuario, id_endereco_entrega, metodo_pagamento: metodoPagamentoFinal,
            preco_itens, preco_frete, preco_total, 
            status_pagamento: statusPagamento,
            id_pagamento_gateway: pagamentoResult.id.toString(),
        }, carrinhoItens);

        await CarrinhoModel.clear(id_usuario);

        if (paymentMethod === 'CreditCard') {
            res.status(201).json({ 
                message: `Pagamento ${statusPagamento === 'PAGO' ? 'aprovado' : 'pendente'}.`, 
                orderId: pedidoCriado.id_pedido 
            });
        } else {
            res.status(201).json({
                message: "Pedido criado! Aguardando pagamento PIX.",
                paymentInfo: {
                    id_pagamento: pagamentoResult.id,
                    qr_code: pagamentoResult.point_of_interaction?.transaction_data?.qr_code,
                    qr_code_base64: pagamentoResult.point_of_interaction?.transaction_data?.qr_code_base64,
                }
            });
        }

    } catch (error) {
        next(error);
    }
};

export const getPedidoById = async (req, res, next) => {
    try {
        const id_pedido = req.params.id;
        const id_usuario_logado = req.user.id_usuario;
        const is_admin_logado = req.user.isAdmin;

        // Se o utilizador for admin, ele pode ver qualquer pedido.
        // Se não for, ele só pode ver os seus próprios pedidos.
        const pedidoCompleto = await PedidoModel.findById(
            id_pedido, 
            is_admin_logado ? undefined : id_usuario_logado
        );

        if (pedidoCompleto) {
            res.status(200).json(pedidoCompleto);
        } else {
            res.status(404).json({ message: 'Pedido não encontrado.' });
        }
    } catch (error) {
        next(error);
    }
};

export const getMeusPedidos = async (req, res, next) => {
    try {
        const id_usuario = req.user.id_usuario;
        const pedidos = await PedidoModel.findAllByUserId(id_usuario);
        res.status(200).json(pedidos);
    } catch (error) {
        next(error);
    }
};

// --- ✅ NOVAS FUNÇÕES DE ADMIN ---

// @desc    Listar todos os pedidos (Admin)
export const getAllPedidos = async (req, res, next) => {
    try {
        const pedidos = await PedidoModel.findAll();
        res.json(pedidos);
    } catch (error) {
        next(error);
    }
};

// @desc    Atualizar um pedido para entregue (Admin)
export const updatePedidoParaEntregue = async (req, res, next) => {
    try {
        // Como esta é uma rota de admin, não precisamos de verificar o dono do pedido.
        // Passamos 'undefined' como id_usuario para a função findById.
        const pedido = await PedidoModel.findById(Number(req.params.id), undefined);

        if (pedido) {
            const pedidoAtualizado = await PedidoModel.update(Number(req.params.id), {
                status_entrega: 'Enviado' 
            });
            res.json(pedidoAtualizado);
        } else {
            res.status(404);
            throw new Error('Pedido não encontrado');
        }
    } catch (error) {
        next(error);
    }
};

// @desc    Apagar um pedido (Admin)
export const deletePedido = async (req, res, next) => {
    try {
        await PedidoModel.remove(Number(req.params.id));
        res.json({ message: 'Pedido removido com sucesso' });
    } catch (error) {
        next(error);
    }
};
